
#version 450

#include "SimulationUniforms.glsl"
#include "Fractals.glsl"

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=1, binding=0) uniform writeonly iimage2D iterationCounts;
layout(set=1, binding=1) uniform writeonly image2D fractalImage;

void main() {
  ivec2 texelPos = ivec2(gl_GlobalInvocationID.xy);
  if (texelPos.x < 0 || texelPos.x >= simulation.width ||
      texelPos.y < 0 || texelPos.y >= simulation.height) {
    return;
  }
  
  float h = max(1.0 / simulation.width, 1.0 / simulation.height);

  vec2 c = (
      2.0 * vec2(texelPos) * h 
      - vec2(1.0)) / simulation.zoom
      + simulation.offset;

  const int FRACTAL_ITERS = 10000;
  int i = 0;
  vec2 zn = c;
  float magSq;
  for (; i < FRACTAL_ITERS; ++i) {
    vec2 z2 = vec2(zn.x * zn.x - zn.y * zn.y, 2.0 * zn.x * zn.y);
    zn = z2 + c;
    magSq = dot(zn, zn);
    if (magSq > 4.0) {
      break;
    }
  }

  float mag = sqrt(magSq);
  if (i == FRACTAL_ITERS)
  {
    i = 0;
    mag = 0.0;
  }

  float color1 = float(i + 1) / float(FRACTAL_ITERS);
  // float color2 = (float(i + 1) - log(max(log2(max(mag, 1.000)), 1.000))) / float(FRACTAL_ITERS);
  float color2 = (float(i + 1) - log(max(log2(mag), 0.01))) / float(FRACTAL_ITERS);
  float color = color2;//(1.0 - color2) * (1.0 - mod(float(i), 10.0));
  // * color2 + color1;
  // color = color1;
  imageStore(iterationCounts, texelPos, ivec4(i, 0, 0, 1));
  imageStore(fractalImage, texelPos, vec4(color, 0.0, 0.0, 1.0));
}




