
#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set=0, binding=0) uniform sampler2D velocityField;
layout(set=0, binding=1) uniform writeonly image2D advectedVelocityField;

layout(push_constant) uniform PushConstants {
  int width;
  int height;
  float dt;
  float sorOmega;
  float density;
  float vorticity;
  bool clear;
} pushConstants;

vec2 sampleVel(vec2 uv) {
  vec2 v = texture(velocityField, uv).rg;
  vec2 sn = vec2(1.0);
  if (uv.x < 0 || uv.x > 1.0) {
    sn.x *= -1.0;
  }

  if (uv.y < 0 || uv.y > 1.0) {
    sn.y *= -1.0;
  }

  return sn * v;
}

void main() {
  ivec2 texelPos = ivec2(gl_GlobalInvocationID.xy);
  if (texelPos.x < 0 || texelPos.x >= pushConstants.width ||
      texelPos.y < 0 || texelPos.y >= pushConstants.height) {
    return;
  }

  vec2 cellDims = vec2(1.0) / vec2(pushConstants.width, pushConstants.height);
  vec2 texelUv = 0.5 * cellDims + vec2(texelPos) / vec2(pushConstants.width, pushConstants.height);

  // TODO: Introduce temperature and buoyancy
  // 
  vec2 vel = texture(velocityField, texelUv).rg;
  vec2 srcUv = texelUv - vel * pushConstants.dt;
  vec2 srcVel = texture(velocityField, srcUv).rg;

  // For testing...
  if (srcUv.x <= 0.001 && srcUv.y > 0.45 && srcUv.y < 0.55) {
    srcVel = vec2(0.5, 0.0);
  }

  // Velocities diagonal to the current cell, used multiple
  // times by the curl computation
  vec2 velLD = sampleVel(texelUv - cellDims);
  vec2 velRD = sampleVel(texelUv + vec2(cellDims.x, -cellDims.y));
  vec2 velRU = sampleVel(texelUv + cellDims);
  vec2 velLU = sampleVel(texelUv + vec2(-cellDims.x, cellDims.y));

  vec2 velLL = sampleVel(texelUv + vec2(-2.0 * cellDims.x, 0.0));
  vec2 velRR = sampleVel(texelUv + vec2(2.0 * cellDims.x, 0.0));
  vec2 velDD = sampleVel(texelUv + vec2(0.0, -2.0 * cellDims.y));
  vec2 velUU = sampleVel(texelUv + vec2(0.0, 2.0 * cellDims.y));

  // TODO: Verify curl orientation (right vs left handed)
  float curlL = velLU.x - velLD.x + velLL.y - vel.y;
  float curlR = velRU.x - velRD.x + vel.y - velRR.y;
  float curlD = vel.x - velDD.x + velLD.y - velRD.y;
  float curlU = velUU.x - vel.x + velLU.y - velRU.y;

  vec2 vortConf = vec2(curlD - curlU, curlR - curlL);
  float vortConfMag = length(vortConf);
  if (vortConfMag > 0.00001) {
    vortConf *= cellDims.yx * pushConstants.vorticity / vortConfMag;
  } else {
    vortConf = vec2(0.0);
  }

  imageStore(advectedVelocityField, texelPos, vec4(srcVel + vortConf, 0.0, 1.0));
}




